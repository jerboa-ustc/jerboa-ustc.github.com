---
layout: post
title: APUE笔记：线程私有数据 多线程程序fork
categories:
- APUE
tags:
- 多线程
- fork
- 私有数据
---

jerboa：APUE中关于多线程进程fork有一节的内容，可是呢书上的例子看不出来是为了解决fork后新进程无法解锁而编写的，仅仅是为了体现有pthead_atfork这么一个机制而编写。

[这篇文章](http://blog.codingnow.com/2011/01/fork_multi_thread.html)讲述了服务器中的“多进程的多线程程序”在使用fork时所遇到的实际问题。其中最严重的就是”锁“的问题。

**1 线程私有数据**

**1.1 why & errno**

一个线程拥有的私有数据是CPU寄存器和栈，其余的资源被同进程内其他线程所共享。

那么errno这种”全局变量“是怎么回事呢？很显然它不可能是一个栈上的局部变量，因为线程内所有的函数都可能需要使用它。但errno又不可以是一个存在BSS和DATA段的全局变量，这样进程内所有线程就共享了同一出错信息，显然是不可能的。

到底是怎么回事呢？对于每个线程errno都有一个副本互不干扰。答案在<errno.h>的头文件中的定义处：errno被重新定义为线程私有数据。这样，一个线程设置errno的操作并不会影响进程中其他线程的errno值。

{% highlight c++ %}
# ifndef __ASSEMBLER__
/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __THROW __attribute__ ((__const__));

#  if !defined _LIBC || defined _LIBC_REENTRANT
/* When using threads, errno is a per-thread value.  */
#   define errno (*__errno_location ())
#  endif
# endif /* !__ASSEMBLER__ */
{% endhighlight %}

**1.2 线程私有数据的思路**

线程私有数据采用了”一键多值“思想，即一个”键“对应多个数值。我们可以把”键“想象成一个数组下标，在数个不同的表中此下标对应数个不同的Mem单元。

访问数据通过键值，使用线程私有数据时，首先为每个线程私有数据创建一个关联的”键“。多线程内部使用这个**公用键值**获取本线程的私有数据地址。

**1.3 线程私有数据的设计实现**

系统为每个进程维护一个Key结构数组，初始状态是所有Key结构都不在使用中。当使用ptherad_key_create获取一个”键“的时候，找出第一个不在使用中的Key结构，并返回索引（数组下标）。Key结构中的析构函数指针需要自行指定，一般是free；标志指示此结构是否被使用。

![](/images/2014-05-17-1_3-1.PNG)

除了Key结构数组外，每个线程都有自己的pkey结构数组。pkey结构数组与Key结构数组拥有相同数量的元素。pkey表存储于pthread结构中，每个元素是一个指针，指向本线程与此”键“关联的私有数据地址。

![](/images/2014-05-17-1_3-2.PNG)

**1.4 线程如何找到私有数据**

假设一个多线程进程被启动。

- 其中一个线程调用pthread_key_create。系统在Key结构数组中找到第1个未使用的元素。并把它的索引（0~127）返回给调用者。假设找到的索引为1（*TIPS:使用pthread_once 函数确保pthread_key_create只被调用一次。如果一个键创建两次，其实是在创建不同的键，第二个键将覆盖第一个，第一个键与任何线程可能为其设置的值将一起永远的丢失。*）
- 接着使用pthread_setspecific绑定”键“与堆上申请的地址空间（*如果没有线程私有数据值与键关联，pthread_getspecific键返回NULL，可以依据此来确定是否调用pthread_setspecific*）
- 最后使用pthread_getspecific获取已有的私有数据地址

示例代码


{% highlight c++ %}
/*************************************************************************
	> File Name: TSD1.c
	> Author: jerboa
	> Mail: a.jerboa@gmail.com
	> Created Time: 2014年05月13日 星期二 10时27分47秒
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct private_tag{
	pthread_t	thread_id;
	char *string;
}private_t;

pthread_key_t	identity_key0;
pthread_mutex_t	identity_key0_mutex = PTHREAD_MUTEX_INITIALIZER;
int				identity_key0_counter = 0;

void identity_key0_destructor(void *);
void *identity_key0_get(void);
void *identity_key0_make(void);
void *thread_routine(void *arg);
void pr_private_data(void *);

void identity_key0_destructor(void *addr)
{
	private_t *private = (private_t *)addr;
	int status;

	printf("%s: 0x%x exiting...\n", private->string, private->thread_id);
	pr_private_data(addr);
	free(private);
	status = pthread_mutex_lock(&identity_key0_mutex);
	if(status != 0)
		perror("thread_mutex_lock() error");

	identity_key0_counter--;

	if(identity_key0_counter <= 0)
	{
		status = pthread_key_delete(identity_key0);
		if(status != 0)
			perror("pthread_key_delete() error");
		printf("key: identity_key0 deleted...\n");
	}

	status = pthread_mutex_unlock(&identity_key0_mutex);
}

void *identity_key0_get(void)
{
	void *addr;
	int status;

	addr = pthread_getspecific(identity_key0);
	if(addr == NULL)
	{
		addr = malloc(sizeof(private_t));
		if(addr == NULL)
			perror("heap: malloc() error");
		status = pthread_setspecific(identity_key0, (void *)addr);
		if(status != 0)
			perror("pthread_setspecific() error");
	}

	return addr;
}

void * identity_key0_make(void)
{
	int status;
	status = pthread_key_create(&identity_key0, identity_key0_destructor);
	if(status != 0)
		perror("pthread_key_careate() error");
	identity_key0_counter = 3;		/*3 threads to go*/

	return (void*)(status);
}

void *thread_routine(void *arg)
{
	private_t *addr;

	addr = (private_t *)identity_key0_get();
	addr->thread_id = pthread_self();
	addr->string = (char *)arg;
	printf("%s: 0x%x starting...\n",addr->string,  addr->thread_id);
	sleep(2);
	return NULL;
}

void pr_private_data(void *addr)
{
	private_t *private = (private_t *)addr;
	printf("private data: at %p, thread_id = 0x%x | string = %s\n", private, private->thread_id, private->string);
}

void main(int argc, char *argv[])
{
	pthread_t thread_1, thread_2;
	private_t *addr;
	int status;

	//printf("%s: 0x%x starting...\n", "thread_0", pthread_self());
	status = (int)identity_key0_make();
	if(status != 0)
		perror("cant create identity_key0");
	addr = (private_t *)identity_key0_get();
	addr->thread_id = pthread_self();
	addr->string = "thread_0";
	printf("%s :0x%x starting...\n", addr->string, addr->thread_id);
	status = pthread_create(&thread_1, NULL, thread_routine, "thread_1");
	if(status != 0)
		perror("pthread_create() error");
	status = pthread_create(&thread_2, NULL, thread_routine, "thread_2");
	if(status != 0)
		perror("pthread_create() error");

	pthread_exit(NULL);
}
{% endhighlight %}

![](/images/2014-05-17-1_4-1.PNG)

**1.5 释放**

当一个线程终止时，系统将扫描该线程的pkey数组，为每个非空的pkey指针调用相应的析构函数。相应的析构函数是存放在图1中的Key数组中的函数指针。这是一个线程终止时其线程特定数据的释放手段。

**2 多线程与fork**

**2.1 多线程fork引发的奇怪的错误和APUE解决方案**

先摘抄一段开篇那个梦幻西游服务器多线程优化的文章。

> 在 POSIX 标准中，fork 的行为是这样的：复制整个用户空间的数据（通常使用 copy-on-write 的策略，所以可以实现的速度很快）以及所有系统对象，然后仅复制当前线程到子进程。这里：所有父进程中别的线程，到了子进程中都是**突然蒸发掉**的。
 
>其它线程的突然消失，是一切问题的根源。

>我之前从未写过多进程多线程程序，不过公司里有 David Xu 同学（他实现维护着 FreeBSD 的线程库）是这方面的专家，今天跟徐同学讨论了一下午，终于觉得自己搞明白了其中的纠结。嗯，写点东西整理一下思路。

>可能产生的最严重的问题是锁的问题。

>因为为了性能，大部分系统的锁是实现在用户空间的。所以锁对象会因为 fork 复制到子进程中。

>对于锁来说，从 OS 看，**每个锁有一个所有者，即最后一次 lock 它的线程**。

>假设这么一个环境，在 fork 之前，有一个子线程 lock 了某个锁，获得了对锁的所有权。fork 以后，在子进程中，所有的额外线程都人间蒸发了。而锁却被正常复制了，在子进程看来，**这个锁没有主人，所以没有任何人可以对它解锁**。

>当子进程想 lock 这个锁时，不再有任何手段可以解开了。程序发生死锁。

在APUE书对于由于fork而产生的死锁示例可能意图不够明显，因为接下来可以看到例子中仅仅是父子进程在一个没有上锁的环境中分别上锁在分别解锁。  
而真正的死锁产生可能是这样的：进程A的线程A-2给进程中的锁上锁，但还未解锁时就被打断，进程A的线程A-1使用fork创建子进程B。进程B发现自己继承自A的锁没有所有权不能解锁（因为fork时线程A-1没有对锁的所有权，而B中A-2线程的副本已经 *蒸发* 了）。

APUE cht12中简易使用pthread\_arfork对父子进程注册3个handlers进行自定义的预处理和后期处理。例如命名为prepare\_fork, parent\_fork, child\_fork。

APUE摘抄。

>prepare\_fork处理程序由**父进程在fork创建子进程前**调用，这个fork处理程序的任务是获取父进程定义的所有锁。

>parent\_fork处理程序是在fork创建了子程序以后，但是在**fork返回之前在父进程环境中**调用的，这个fork处理程序的任务是对prepare\_fork处理程序获得的所有所进程解锁。

>child\_fork处理程序在**fork返回之前在子程序进程环境中**调用，与parent\_fork处理程序一样，child\_fork处理程序也必须释放prepare\_fork处理程序的所有锁。

事件序列如下

> pthread\_atfork handlers
> 
>- 父进程获得所有的锁
>- 子进程获得所有的锁
>- 父进程释放**它**的锁
>- 子进程释放**它**的锁


{% highlight c++ %}
#include "apue.h"
#include <pthread.h>

pthread_mutex_t lock1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;

void
prepare(void)
{
    printf("preparing locks...\n");
    pthread_mutex_lock(&lock1);
    pthread_mutex_lock(&lock2);
}

void 
parent(void)
{
    printf("parent unlocking locks...\n");
    pthread_mutex_unlock(&lock1);
    pthread_mutex_unlock(&lock2);
}

void
child(void)
{
    printf("child unlocking locks...\n");
    pthread_mutex_unlock(&lock1);
    pthread_mutex_unlock(&lock2);
}

void *
thr_fn(void *arg)
{
    printf("thread started...\n");
	pause();
    return(0);
}

int
main(void)
{
    int        err;
    pid_t      pid;
    pthread_t  tid;
    
#if defined(BSD) || defined(MACOS)
    printf("pthread_atfork is unsupported\n");
#else
    if((err = pthread_atfork(prepare, parent, child)) != 0)
        err_exit(err, "can't install fork handlers");
    err = pthread_create(&tid, NULL, thr_fn, 0);
    if(err != 0)
        err_exit(err, "can't create thread");
    sleep(1);
    printf("parent about to fork...\n");    
    if((pid = fork()) < 0)
        err_quit("fork failed");
    else if(pid == 0)    /* child */
        printf("child returned from fork\n");
    else    /* parent */
        printf("parent returned from fork\n");
#endif
    exit(0);
}
{% endhighlight %}

不用想，结果肯定是个皆大欢喜的效果，看起来一切都已经解决了。

实际上应该用线程1锁住，然后用不拥有锁的线程2fork子进程，最后子进程再锁住一些锁。这样才是pthread_atfork的作用。如下，

{% highlight c++ %}
#include "apue.h"
#include <pthread.h>
#include <errno.h>

pthread_mutex_t lock1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;

void
prepare(void)
{
    printf("preparing locks mutex @lock1 @lock2...\n");
    pthread_mutex_lock(&lock1);
    pthread_mutex_lock(&lock2);
}

void 
parent(void)
{
    printf("parent unlocking mutex @lock1 @lock2...\n");
    pthread_mutex_unlock(&lock1);
	pthread_mutex_unlock(&lock2);
}

void
child(void)
{
    printf("child unlocking mutex @lock1 @lock2...\n");
    pthread_mutex_unlock(&lock1);
	 pthread_mutex_unlock(&lock2);
}

void *
thr_fn(void *arg)
{
	int err;
	pid_t child_proc;
	printf("thread start...\n");	
	if((child_proc = fork()) < 0)
		err_quit("fork error");
	else if(child_proc == 0)
	{
		err = pthread_mutex_lock(&lock1);
		if(err == 0)
			printf("lock mutex @lock1 in child proc\n");
		else
			err_exit(err, "cant lock mutex @lock1 in child proc");
		err = pthread_mutex_unlock(&lock1);
		if(err == 0)
			printf("unlock mutex @lock1 in child proc\n");
		else
			err_exit(err, "cant unlock mutex @lock1 in child proc");
	}
	else
	{
		;
	}
    pthread_exit(0);
}

int
main(void)
{
    int        err;
    pid_t        pid;
    pthread_t    tid;
    
#if defined(BSD) || defined(MACOS)
    printf("pthread_atfork is unsupported\n");
#else
    if((err = pthread_atfork(prepare, parent, child)) != 0)
        err_exit(err, "cant install fork handlers");
	
	err = pthread_mutex_lock(&lock1);
	if(err == 0)
		printf("lock mutex @lock1 in father proc 1st-therad\n");
	else
		err_exit(err, "cant lock mutex");

    err = pthread_create(&tid, NULL, thr_fn, 0);
    if(err != 0)
        err_exit(err, "can't create thread");
	
	sleep(5);

	err = pthread_mutex_unlock(&lock1);
	if(err == 0)
		printf("unlock mutex @lock1 in father proc 1st-thread\n");
	else
		err_exit(err, "cant unlcok mutex");
#endif
    //exit(0);
	pthread_exit(0);
}
{% endhighlight %}

![](/images/2014-05-17-2_1-1.PNG)

更加接近实际的用例是这样的，如下。我们不可能使用mutex这种锁来同步，而是要使用cond条件变量锁和mutex一起同步多线程。要考虑超时的影响，需要使用cond条件变量的超时锁和singal。

{% highlight c++ %}
cont...
{% endhighlight %}

**2.2 某些多线程准则**

所谓的准则就是一堆*经验* ，至于为什么，本菜也不知道。

- 做fork的时候,在它之前让其他的线程完全终止
- fork后在子进程中马上调用exec函数（exec可以覆盖内存空间，可以解决所有关于锁的问题）
- ”其他线程”中,不做fork-unsafe的处理
- 使用pthread\_atfork函数,在即将fork之前调用事先准备的回调函数（*使用pthread\_atfork函数,在即将fork之前调用事先准备的回调函数,在这个回调函数内,协商清除进程的内存数据.但是关于OS提供的函数(例:malloc),在回调函数里没有清除它的方法.因为malloc里使用的数据结构在外部是看不见的.因此,pthread\_atfork函数几乎是没有什么实用价值的*）
- 在多线程程序里,不使用fork（这样不可能，记得osean base和redis大量的 *主线程-多个从线程-独立I/O进程* 的设计，不知道记错没有）

综上，比较**靠谱**的解决方法还是这两个

- 先fork()后再用pthread，增加可移植性
- fork后在子进程中马上调用exec函数

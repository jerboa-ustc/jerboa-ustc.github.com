---
layout: post
title: APUE笔记：线程私有数据 多线程程序fork
categories:
- APUE
tags:
- 多线程
- fork
- 私有数据
---

jerboa：APUE中关于多线程进程fork有一节的内容，可是呢书上的例子看不出来是为了解决fork后新进程无法解锁而编写的，仅仅是为了体现有pthead_atfork这么一个机制而编写。

[这篇文章](http://blog.codingnow.com/2011/01/fork_multi_thread.html)讲述了服务器中的“多进程的多线程程序”在使用fork时所遇到的实际问题。其中最严重的就是”锁“的问题。

**1 线程私有数据**

**1.1 why & errno**

一个线程拥有的私有数据是CPU寄存器和栈，其余的资源被同进程内其他线程所共享。

那么errno这种”全局变量“是怎么回事呢？很显然它不可能是一个栈上的局部变量，因为线程内所有的函数都可能需要使用它。但errno又不可以是一个存在BSS和DATA段的全局变量，这样进程内所有线程就共享了同一出错信息，显然是不可能的。

到底是怎么回事呢？对于每个线程errno都有一个副本互不干扰。答案在<errno.h>的头文件中的定义处：errno被重新定义为线程私有数据。这样，一个线程设置errno的操作并不会影响进程中其他线程的errno值。

{% highlight c++ %}
# ifndef __ASSEMBLER__
/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __THROW __attribute__ ((__const__));

#  if !defined _LIBC || defined _LIBC_REENTRANT
/* When using threads, errno is a per-thread value.  */
#   define errno (*__errno_location ())
#  endif
# endif /* !__ASSEMBLER__ */
{% endhighlight %}

**1.2 线程私有数据的思路**

线程私有数据采用了”一键多值“思想，即一个”键“对应多个数值。我们可以把”键“想象成一个数组下标，在数个不同的表中此下标对应数个不同的Mem单元。

访问数据通过键值，使用线程私有数据时，首先为每个线程私有数据创建一个关联的”键“。多线程内部使用这个**公用键值**获取本线程的私有数据地址。

**1.3 线程私有数据的设计实现**

系统为每个进程维护一个Key结构数组，初始状态是所有Key结构都不在使用中。当使用ptherad_key_create获取一个”键“的时候，找出第一个不在使用中的Key结构，并返回索引（数组下标）。Key结构中的析构函数指针需要自行指定，一般是free；标志指示此结构是否被使用。

![](/images/2014-05-17-1_3-1.PNG)

除了Key结构数组外，每个线程都有自己的pkey结构数组。pkey结构数组与Key结构数组拥有相同数量的元素。pkey表存储于pthread结构中，每个元素是一个指针，指向本线程与此”键“关联的私有数据地址。

![](/images/2014-05-17-1_3-2.PNG)

**1.4 线程如何找到私有数据**

假设一个多线程进程被启动。

- 其中一个线程调用pthread_key_create。系统在Key结构数组中找到第1个未使用的元素。并把它的索引（0~127）返回给调用者。假设找到的索引为1（*TIPS:使用pthread_once 函数确保pthread_key_create只被调用一次。如果一个键创建两次，其实是在创建不同的键，第二个键将覆盖第一个，第一个键与任何线程可能为其设置的值将一起永远的丢失。*）
- 接着使用pthread_setspecific绑定”键“与堆上申请的地址空间（*如果没有线程私有数据值与键关联，pthread_getspecific键返回NULL，可以依据此来确定是否调用pthread_setspecific*）
- 最后使用pthread_getspecific获取已有的私有数据地址

示例代码


{% highlight c++ %}
/*************************************************************************
	> File Name: TSD1.c
	> Author: jerboa
	> Mail: a.jerboa@gmail.com
	> Created Time: 2014年05月13日 星期二 10时27分47秒
 ************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

typedef struct private_tag{
	pthread_t	thread_id;
	char *string;
}private_t;

pthread_key_t	identity_key0;
pthread_mutex_t	identity_key0_mutex = PTHREAD_MUTEX_INITIALIZER;
int				identity_key0_counter = 0;

void identity_key0_destructor(void *);
void *identity_key0_get(void);
void *identity_key0_make(void);
void *thread_routine(void *arg);
void pr_private_data(void *);

void identity_key0_destructor(void *addr)
{
	private_t *private = (private_t *)addr;
	int status;

	printf("%s: 0x%x exiting...\n", private->string, private->thread_id);
	pr_private_data(addr);
	free(private);
	status = pthread_mutex_lock(&identity_key0_mutex);
	if(status != 0)
		perror("thread_mutex_lock() error");

	identity_key0_counter--;

	if(identity_key0_counter <= 0)
	{
		status = pthread_key_delete(identity_key0);
		if(status != 0)
			perror("pthread_key_delete() error");
		printf("key: identity_key0 deleted...\n");
	}

	status = pthread_mutex_unlock(&identity_key0_mutex);
}

void *identity_key0_get(void)
{
	void *addr;
	int status;

	addr = pthread_getspecific(identity_key0);
	if(addr == NULL)
	{
		addr = malloc(sizeof(private_t));
		if(addr == NULL)
			perror("heap: malloc() error");
		status = pthread_setspecific(identity_key0, (void *)addr);
		if(status != 0)
			perror("pthread_setspecific() error");
	}

	return addr;
}

void * identity_key0_make(void)
{
	int status;
	status = pthread_key_create(&identity_key0, identity_key0_destructor);
	if(status != 0)
		perror("pthread_key_careate() error");
	identity_key0_counter = 3;		/*3 threads to go*/

	return (void*)(status);
}

void *thread_routine(void *arg)
{
	private_t *addr;

	addr = (private_t *)identity_key0_get();
	addr->thread_id = pthread_self();
	addr->string = (char *)arg;
	printf("%s: 0x%x starting...\n",addr->string,  addr->thread_id);
	sleep(2);
	return NULL;
}

void pr_private_data(void *addr)
{
	private_t *private = (private_t *)addr;
	printf("private data: at %p, thread_id = 0x%x | string = %s\n", private, private->thread_id, private->string);
}

void main(int argc, char *argv[])
{
	pthread_t thread_1, thread_2;
	private_t *addr;
	int status;

	//printf("%s: 0x%x starting...\n", "thread_0", pthread_self());
	status = (int)identity_key0_make();
	if(status != 0)
		perror("cant create identity_key0");
	addr = (private_t *)identity_key0_get();
	addr->thread_id = pthread_self();
	addr->string = "thread_0";
	printf("%s :0x%x starting...\n", addr->string, addr->thread_id);
	status = pthread_create(&thread_1, NULL, thread_routine, "thread_1");
	if(status != 0)
		perror("pthread_create() error");
	status = pthread_create(&thread_2, NULL, thread_routine, "thread_2");
	if(status != 0)
		perror("pthread_create() error");

	pthread_exit(NULL);
}
{% endhighlight %}

![](/images/2014-05-17-1_4-1.PNG)

**1.5 释放**

当一个线程终止时，系统将扫描该线程的pkey数组，为每个非空的pkey指针调用相应的析构函数。相应的析构函数是存放在图1中的Key数组中的函数指针。这是一个线程终止时其线程特定数据的释放手段。
---
layout: post
title: 算法 时间复杂度
categories:
- 算法
- 时间复杂度
- Programming
---

jerboa:
29号参加了某公司的笔试，里面有两个时间复杂度没有算出结果，真是很生气。特别是那个SkipList在2月份的时候自己还实现了一遍放在git@oschina上，可是这次仍然没有算出时间！可能人们的愤怒都是出于对自己无能而发出的吧。

**0. 准备**

[这篇文章](http://blog.csdn.net/hitwhylz/article/details/12374407)粗略讲述了如何计算简单的复杂度，可以直接到跳到最后一节--汉诺塔的时间复杂度计算。

**1. 快排的时间复杂度计算**

计算主要运行语句的执行次数T(n).

- T(n)的计数主要是由 *本次挖坑填数* 和 *下一次快排操作* 构成.
- 本次挖坑填数的运行次数是n/(2^i)，因为有两个指针，一前一后相向而行直到相遇，i是指第i+1次快排.
- 综上，T(n) = T(n-1)2 + n/(2^0), T(n-1) = T(n-2)2 + n/(2^1), ... T(2) = T(1)2 + 1.

可得出T(n) = n/(2^0) + T(n-1)2 = n + [n/(2^1) + T(n-2)2]2 = n + 2[n/(2^1) + (n/(2^2) + T(n-3)2)2].  
化简可得，T(n) = n + 2T(n-1) = 2n + 2^2T(n-2) = 3n + 2^3T(n-3) = ... = (log2^n)n + 2^(log2^n)T(1) = n + nlog2^n.

得出，快排时间复杂度为O(nlog2^n).

**2. 二路归并排序时间爱你复杂度计算**

同快排，一共归并了log2^n趟，每趟归并总的比较次数为n，所以T(n) = nlog2^n + 2(log2^n)T(1) = nlog2^n + n.

复杂度为O(nlog2^n).

**3. 多路归并**

设有n路，每路有m个元素。

- 首先并发的给n路分别排好序，花费O(mlog2^m).
- 再从n路中，选择第一个元素建堆，花费O(n).建堆花费时间下面证明.
- 最后需要调整堆大概nm次，每次调整为O(h),则调整共花费O(nmlog2^n).

综上，多路归并排序时间复杂度O(n) = O(mlog2^m) + O(n) + O(nmlog2^n) = O(nmlog2^n).

如果初始各序列已经有序，则共花费O(n) = O(n) + O(nmlog2^n) = O(nmlog2^n).

**4. 堆排序中建堆时间复杂度**

为了简化过程，我们设定要调整的堆恰好是一个满二叉树（正常情况下是完全二叉树）.树从上到下层级编号为1, 2, 3 ,... h-1, h.那么建堆时需要调整的节点在第h-1层，第h-2层，...，第2层，第1层。每层需要调整的次数为：  

![](/images/2014-03-31-1.jpg)

那么，T(n) = 2^(h-2)1 + 2^(h-3)2 + 2^(h-4)3 + ... + 2^2(h-3) + 2^1(h-2) + 2^0(h-1),  
(努力对齐....)1/2(T(n)) = 2^(h-3)1 + 2^(h-4)2 + ... + 2^2(h-4) + 2^1(h-3) + 2^0(h-2) + 2^(-1)(h-1).

两式相减得，T(n) - (1/2)T(n) = (1/2)T(n) = 2^(h-2) + 2^(h-3) + 2^(h-4) + ... + 2^1 + 2^0 - 2^(-1)(h-1) = 2^(h-1) - 2^(-1)(h-1) - 1  
将h = log2^n带入，得T(n) = n/2 - 1/2(log2^n) -1/2

综上，O(T(n)) = O(n).

** 5. 待定**


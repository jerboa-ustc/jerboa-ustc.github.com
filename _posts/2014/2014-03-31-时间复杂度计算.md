---
layout: post
title: 算法 时间复杂度
categories:
- 时间复杂度
tags:
- 算法
- 时间复杂度
---

jerboa:
29号参加了某公司的笔试，里面有两个时间复杂度没有算出结果，真是很生气。特别是那个SkipList在2月份的时候自己还实现了一遍放在git@oschina上，可是这次仍然没有算出时间！借用李娜的话：

> “愤怒是对自己无能的痛苦”。

**0. 准备**

[这篇文章](http://blog.csdn.net/hitwhylz/article/details/12374407)粗略讲述了如何计算简单的复杂度，可以直接到跳到最后一节--汉诺塔的时间复杂度计算。

**1. 快排的时间复杂度计算**

计算主要运行语句的执行次数T(n).

- T(n)的计数主要是由 *本次挖坑填数* 和 *下一次快排操作* 构成.
- 本次挖坑填数的运行次数是n/(2^i)，因为有两个指针，一前一后相向而行直到相遇，i是指第i+1次快排.
- 综上，T(n) = T(n-1)2 + n/(2^0), T(n-1) = T(n-2)2 + n/(2^1), ... T(2) = T(1)2 + 1.

可得出T(n) = n/(2^0) + T(n-1)2 = n + [n/(2^1) + T(n-2)2]2 = n + 2[n/(2^1) + (n/(2^2) + T(n-3)2)2].  
化简可得，T(n) = n + 2T(n-1) = 2n + 2^2T(n-2) = 3n + 2^3T(n-3) = ... = (log2^n)n + 2^(log2^n)T(1) = n + nlog2^n.

得出，快排时间复杂度为**O(nlog2^n)**.

> we're goona get more info? let's roll.

![](/images/2014-03-31-1-1.jpg)

![](/images/2014-03-31-1-2.jpg)

> 可得，快排实际运行时间为 **2n ln n = 1.39 nlgn**。

**2. 二路归并排序时间复杂度计算**

同快排，一共归并了log2^n趟，每趟归并总的比较次数为n，所以T(n) = nlog2^n + 2(log2^n)T(1) = nlog2^n + n.

复杂度为**O(nlog2^n)**.

**3. 多路归并**

设有n路，每路有m个元素。

- 首先并发的给n路分别排好序，花费O(mlog2^m).
- 再从n路中，选择第一个元素建堆，花费O(n).建堆花费时间下面证明.
- 最后需要调整堆大概nm次，每次调整为O(h),则调整共花费O(nmlog2^n).

综上，多路归并排序时间复杂度O(n) = O(mlog2^m) + O(n) + O(nmlog2^n) = **O(nmlog2^n)**.

如果初始各序列已经有序，则共花费O(n) = O(n) + O(nmlog2^n) = O(nmlog2^n).

**4. 堆排序中建堆时间复杂度**

为了简化过程，我们设定要调整的堆恰好是一个满二叉树（正常情况下是完全二叉树）.树从上到下层级编号为1, 2, 3 ,... h-1, h.那么建堆时需要调整的节点在第h-1层，第h-2层，...，第2层，第1层。每层需要调整的次数为：  

![](/images/2014-03-31-1.jpg)

那么，T(n) = 2^(h-2)1 + 2^(h-3)2 + 2^(h-4)3 + ... + 2^2(h-3) + 2^1(h-2) + 2^0(h-1),  
(努力对齐.......)1/2(T(n)) = 2^(h-3)1 + 2^(h-4)2 + ... + 2^2(h-4) + 2^1(h-3) + 2^0(h-2) + 2^(-1)(h-1).

两式相减得，T(n) - (1/2)T(n) = (1/2)T(n) = 2^(h-2) + 2^(h-3) + 2^(h-4) + ... + 2^1 + 2^0 - 2^(-1)(h-1) = 2^(h-1) - 2^(-1)(h-1) - 1  
将h = log2^n带入，得T(n) = n/2 - 1/2(log2^n) -1/2

综上，O(T(n)) = **O(n)**.

**5. BST / 伸展BST / 2,3,4树 / 红黑树 / 二分插值搜索 / 跳跃表 的时间复杂度**

**5.1 关于对数log与lg的说明**

正常情况下，我们使用的时间复杂度无非是以下几种：

- O(1)，执行至多几次，时间为常量。
- O(log2^N)，程序运行时间为对数，随着N的增长稍微变慢。通常这种情况出现在解决一个大规模问题时，递归的解决划分好的小问题中。**这样每一步都把原问题规模缩小为几分之几后在求解，不要求子问题组合**。在我们现在力所能及的范围内求解，可以“简单”得认为运行时间小于一个大的常数。对数的基底为2或者10会改变这个常数，但是可以认为对于问题规模没有影响，因为：当N=1 000时，如果底数为10则lgN=3，如果底数为2则lgN=10；当N=1 000 000时，如果底数为10则lgN为6，如果底数为2则lgN=19.9。可以看出**log2 与 log10 只相差几倍而已，在同一数量级上**。当N加倍时，logN只增加常量。
- N，程序运行时间为线性。
- Nlog N，**把问题分解成小的子问题，而且独立求解，然后再把子问题的解组合成原问题的解**。这时就会出现Nlog N的时间。当N加倍时（N=2N），运行时间略多于2倍，**也就是略大于线性时间**。
- N^2，运行时间为二次，没什么说的。只能解决小规模问题。
- N^3，小规模问题，如用动态规划中的多源最小路径Floyd-Warshall。
- 2^N，你在写什么？
 
**在分析时间时，通常将log以2为底 简化为 lg。 -- log2N = lgN。**  
lg lgN 我们认为它是个常数，即使N可能很大。

**5.2 二分插值搜索**

二分搜索的时间复杂度为lgN，因为有一次缩小原问题规模的过程。更精确的表达是，搜索命中或者失败，比较次数不超过 **lgN(向下取整)+1 次**。

二分插值搜索有两次缩小原问题规模的过程，所以时间复杂度为**O(lg lgN)**。

**5.3 BST**

要求出BST的搜索时间复杂度，就是求出BST的平均路径长度+1。

设树中所有节点到根的路径长度之和为C(n)，而且随机化的BST插入，使得每一个点都可能是根，所以

![](/images/2014-03-31-5_3.gif)

N-1是指，根节点到剩余N-1个节点的路径需要在C(n-1)的基础上在+1，而且1/N表示，任何一个节点都有可能成为根节点。

上述递推公式的证明和快排一样，最后可得结果

![](/images/2014-03-31-5_3-2.gif)

而2N lnN = 1.39N lgN。  
所以，**平均搜索路径长度为C(n)/N = 2 lnN = 1.39 lgN次**。

综上，BST的命中和失败平均次数为1.39 lgN次，即**复杂度为O(lgN)**。最坏时间复杂度为O(N)，这时，BST是一个先序=中序 或者 后序=中序 的树。  
构造一颗BST需要O(nlgn)时间。

至于根插法的BST，因为需要把新插入节点带到根，需要返回值逐步rot操作，所以时间可能比BST标准插入要大，小于伸展BST插入（类似AVL的4步旋转法）。

**5.4 伸展BST树**

伸展BST需要逐步进行“左-左”，“左-右”，“右-右”，“右-左”旋转，所以在空树中插入N个节点需要比较O(NlgN)次，更精确的表示是 3NlgN 次。

伸展BST的搜索和插入一样，都要逐步旋转，把搜索路径上的点全部带到根附近，相当于几次BST插入（本菜脑补），所以时间复杂度为O(NlgN)。

**在一个N个节点的伸展BST中，执行M次插入或者搜索，要求的比较次数是O((N+M) lg(N+M))**。

**5.5 2-3-4树**

这里，不会证明2,3,4的时间复杂度。

在N各节点的2-3-4树中进行搜索，**最多访问 lgN+1** 个节点。

**5.6 红黑树**

这里，不会证明红黑树的时间复杂度。

红黑树是2-3-4树的二叉树表示法，逻辑上还是一颗2-3-4树。可以直接使用BST的接口进行搜索，使用2-3-4树的方法调整平衡（红黑树用调整链接的“红”、“黑”和旋转来模拟2-3-4的分裂）。

在N各节点的红黑树中，进行一次搜索所需的**比较次数少于O(2 lgN + 2)**次。  
在由随机生成的N个节点的红黑树中，搜索一次，**平均需要 1.002 lgN** 次比较。

**5.7 跳跃表**

待续...

平均情况下，**在参数为t的随机化跳跃表中进行搜索和插入操作需要大约 (t logt^N)/2** = (t/2 lgt)lgN 次比较。  
即时间复杂度为**O(t logt^N)**。
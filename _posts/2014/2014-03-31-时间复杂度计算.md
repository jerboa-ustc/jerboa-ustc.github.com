---
layout: post
title: 算法 时间复杂度
categories:
- 时间复杂度
tags:
- 算法
- 时间复杂度
---

jerboa:
29号参加了某公司的笔试，里面有两个时间复杂度没有算出结果，真是很生气。特别是那个SkipList在2月份的时候自己还实现了一遍放在[git@oschina](https://git.oschina.net/jerboa/Algorithms-in-C-1-4.git)上，![](/images/2014-03-31-0.jpg)可是这次仍然没有算出时间！借用李娜的话：

> *“愤怒是对自己无能的痛苦”。*

**0. 准备**

**0.1 基础知识**

[这篇文章](http://blog.csdn.net/hitwhylz/article/details/12374407)粗略讲述了如何计算简单的复杂度，可以直接到跳到最后一节--汉诺塔的时间复杂度计算。

**0.2 关于对数log与lg的说明**

正常情况下，我们使用的时间复杂度无非是以下几种：

- O(1)，执行至多几次，时间为常量。
- O(log2^N)，程序运行时间为对数，随着N的增长稍微变慢。通常这种情况出现在解决一个大规模问题时，递归的解决划分好的小问题中。**这样每一步都把原问题规模缩小为几分之几后在求解，不要求子问题组合**。在我们现在力所能及的范围内求解，可以“简单”得认为运行时间小于一个大的常数。对数的基底为2或者10会改变这个常数，但是可以认为对于问题规模没有影响，因为：当N=1 000时，如果底数为10则lgN=3，如果底数为2则lgN=10；当N=1 000 000时，如果底数为10则lgN为6，如果底数为2则lgN=19.9。可以看出**log2 与 log10 只相差几倍而已，在同一数量级上**。当N加倍时，logN只增加常量。
- N，程序运行时间为线性。
- Nlog N，**把问题分解成小的子问题，而且独立求解，然后再把子问题的解组合成原问题的解**。这时就会出现Nlog N的时间。当N加倍时（N=2N），运行时间略多于2倍，**也就是略大于线性时间**。
- N^2，运行时间为二次，没什么说的。只能解决小规模问题。
- N^3，小规模问题，如用动态规划中的多源最小路径Floyd-Warshall。
- 2^N，你在写什么？计算Fibonacci不需要用(1.618^n)的递归，要使用O(n)的迭代法。

**在分析时间时，通常将log以2为底 简化为 lg。 -- log2N = lgN。**  
lg lgN 我们认为它是个常数，即使N可能很大。

**1. 快排的时间复杂度计算**

**1.1 理想的快排**

计算主要运行语句的执行次数T(n).先假设快排每次都能平均的分为两个近似等长的子问题，以简化步骤，若追求完美的随机化快排，可跳过1.1节，直接看1.2节。

- T(n)的计数主要是由 *本次挖坑填数* 和 *下一次快排操作* 构成.
- 本次挖坑填数的运行次数是n/(2^i)，因为有两个指针，一前一后相向而行直到相遇，i是指第i+1次快排.
- 综上，T(n) = T(n-1)2 + n/(2^0), T(n-1) = T(n-2)2 + n/(2^1), ... T(2) = T(1)2 + 1.

可得出T(n) = n/(2^0) + T(n-1)2 = n + [n/(2^1) + T(n-2)2]2 = n + 2[n/(2^1) + (n/(2^2) + T(n-3)2)2].  
化简可得，T(n) = n + 2T(n-1) = 2n + 2^2T(n-2) = 3n + 2^3T(n-3) = ... = (log2^n)n + 2^(log2^n)T(1) = n + nlog2^n.

得出，快排时间复杂度为**O(nlog2^n)**.

**1.2 实际使用的快排**

> *we're goona get more info? let's roll.*

![](/images/2014-03-31-1-1.jpg)

![](/images/2014-03-31-1-2.jpg)

> ___可得，快排实际运行时间为 **2n ln n = 1.39 nlgn**。___

**2. 二路归并排序时间复杂度计算**

同快排，一共归并了log2^n趟，每趟归并总的比较次数为n，所以T(n) = nlog2^n + 2(log2^n)T(1) = nlog2^n + n.

复杂度为**O(nlog2^n)**.

**3. 多路归并**

设有n路，每路有m个元素。

- 首先并发的给n路分别排好序，花费O(mlog2^m).
- 再从n路中，选择第一个元素建堆，花费O(n).建堆花费时间下面证明.
- 最后需要调整堆大概nm次，每次调整为O(h),则调整共花费O(nmlog2^n).

综上，多路归并排序时间复杂度O(n) = O(mlog2^m) + O(n) + O(nmlog2^n) = **O(nmlog2^n)**.

如果初始各序列已经有序，则共花费O(n) = O(n) + O(nmlog2^n) = O(nmlog2^n).

*updated 13:38 2014-04-02*

经过老郭和kelvin liu提醒，多路归并还有另一种思路。

- 让m路先有序，花费O(mlog2^m).
- 再从n路中，每2路归并一次（并发执行），需要归并log2^n趟，每趟共需要扫描过O(mn)规模的元素.

综上，一共需要O(mnlog2^n)时间。

**4. 堆排序中建堆时间复杂度**

为了简化过程，我们设定要调整的堆恰好是一个满二叉树（正常情况下是完全二叉树）.树从上到下层级编号为1, 2, 3 ,... h-1, h.那么建堆时需要调整的节点在第h-1层，第h-2层，...，第2层，第1层。每层需要调整的次数为：  

![](/images/2014-03-31-1.jpg)

那么，T(n) = 2^(h-2)1 + 2^(h-3)2 + 2^(h-4)3 + ... + 2^2(h-3) + 2^1(h-2) + 2^0(h-1),  
(努力对齐.......)1/2(T(n)) = 2^(h-3)1 + 2^(h-4)2 + ... + 2^2(h-4) + 2^1(h-3) + 2^0(h-2) + 2^(-1)(h-1).

两式相减得，T(n) - (1/2)T(n) = (1/2)T(n) = 2^(h-2) + 2^(h-3) + 2^(h-4) + ... + 2^1 + 2^0 - 2^(-1)(h-1) = 2^(h-1) - 2^(-1)(h-1) - 1  
将h = log2^n带入，得T(n) = n/2 - 1/2(log2^n) -1/2

综上，O(T(n)) = **O(n)**.

**5. BST / 伸展BST / 2,3,4树 / 红黑树 / 二分插值搜索 / 跳跃表 的时间复杂度**

**5.1 关于对数log与lg的说明**

<del>正常情况下，我们使用的时间复杂度无非是以下几种：

- O(1)，执行至多几次，时间为常量。
- O(log2^N)，程序运行时间为对数，随着N的增长稍微变慢。通常这种情况出现在解决一个大规模问题时，递归的解决划分好的小问题中。**这样每一步都把原问题规模缩小为几分之几后在求解，不要求子问题组合**。在我们现在力所能及的范围内求解，可以“简单”得认为运行时间小于一个大的常数。对数的基底为2或者10会改变这个常数，但是可以认为对于问题规模没有影响，因为：当N=1 000时，如果底数为10则lgN=3，如果底数为2则lgN=10；当N=1 000 000时，如果底数为10则lgN为6，如果底数为2则lgN=19.9。可以看出**log2 与 log10 只相差几倍而已，在同一数量级上**。当N加倍时，logN只增加常量。
- N，程序运行时间为线性。
- Nlog N，**把问题分解成小的子问题，而且独立求解，然后再把子问题的解组合成原问题的解**。这时就会出现Nlog N的时间。当N加倍时（N=2N），运行时间略多于2倍，**也就是略大于线性时间**。
- N^2，运行时间为二次，没什么说的。只能解决小规模问题。
- N^3，小规模问题，如用动态规划中的多源最小路径Floyd-Warshall。
- 2^N，你在写什么？
</del>
 
**在分析时间时，通常将log以2为底 简化为 lg。 -- log2N = lgN。**  
lg lgN 我们认为它是个常数，即使N可能很大。

**5.2 二分插值搜索**

二分搜索的时间复杂度为lgN，因为有一次缩小原问题规模的过程。更精确的表达是，搜索命中或者失败，比较次数不超过 **lgN(向下取整)+1 次**。

二分插值搜索有两次缩小原问题规模的过程，所以时间复杂度为**O(lg lgN)**。

**5.3 BST**

要求出BST的搜索时间复杂度，就是求出BST的平均路径长度+1。

设树中所有节点到根的路径长度之和为C(n)，而且随机化的BST插入，使得每一个点都可能是根，所以

![](/images/2014-03-31-5_3.gif)

N-1是指，根节点到剩余N-1个节点的路径需要在C(n-1)的基础上在+1，而且1/N表示，任何一个节点都有可能成为根节点。

上述递推公式的证明和快排一样，最后可得结果

![](/images/2014-03-31-5_3-2.gif)

而2N lnN = 1.39N lgN。  
所以，**平均搜索路径长度为C(n)/N = 2 lnN = 1.39 lgN次**。

综上，BST的命中和失败平均次数为1.39 lgN次，即**复杂度为O(lgN)**。最坏时间复杂度为O(N)，这时，BST是一个先序=中序 或者 后序=中序 的树。  
构造一颗BST需要O(nlgn)时间。

至于根插法的BST，因为需要把新插入节点带到根，需要返回值逐步rot操作，所以时间可能比BST标准插入要大，小于伸展BST插入（类似AVL的4步旋转法）。

**5.4 伸展BST树**

伸展BST需要逐步进行“左-左”，“左-右”，“右-右”，“右-左”旋转，所以在空树中插入N个节点需要比较O(NlgN)次，更精确的表示是 3NlgN 次。

伸展BST的搜索和插入一样，都要逐步旋转，把搜索路径上的点全部带到根附近，相当于几次BST插入（本菜脑补），所以时间复杂度为O(NlgN)。

**在一个N个节点的伸展BST中，执行M次插入或者搜索，要求的比较次数是O((N+M) lg(N+M))**。

**5.5 2-3-4树**

这里，不会证明2,3,4的时间复杂度。

在N各节点的2-3-4树中进行搜索，**最多访问 lgN+1** 个节点。

在2-3-4树中进行插入，最坏情况下需要少于lgN+1次分裂，最好情况下可能少于1次。

**5.6 红黑树**

这里，不会证明红黑树的时间复杂度。

红黑树是2-3-4树的二叉树表示法，逻辑上还是一颗2-3-4树。可以直接使用BST的接口进行搜索，使用2-3-4树的方法调整平衡（红黑树用调整链接的“红”、“黑”和旋转来模拟2-3-4的分裂）。

在N各节点的红黑树中，进行一次搜索所需的**比较次数少于O(2 lgN + 2)**次。  
在由随机生成的N个节点的红黑树中，搜索一次，**平均需要 1.002 lgN** 次比较。

**5.7 跳跃表**

跳跃表的初步介绍在[这里](http://redisbook.readthedocs.org/en/latest/internal-datastruct/skiplist.html)。

既然SkipList是平衡树的另一种表示，那为什么还要用它而不用2-3-4树和红黑树(而且红黑树更方便，搜索可是直接套用BST的接口，什么都不需要修改)呢?

如果只是简单的比较**搜索**性能，可能红黑树更好。上面已经说明，红黑树最坏只需要2lgN+2次比较，比跳跃表最坏情况O(N)好多了。而平均比较次数，红黑树只需要1.002lgN，而跳跃表需要(e lnN)/2次（跳跃表最好性能为参数P=1/e，即t=e的时候）。当N=1000W，则搜索红黑树需要7.0次，SkipList需要21.7次比较。

*但是*，本菜认为有至少两个原因：

- 红黑树的实现不那么便捷，需要考虑红链接黑链接的储存。为了解决这个问题，可以使用位操作：先设计一个按4Bytes或者8Bytes对齐的结构体，然后这个结构体指针永远用不到最后2bits或者3bits，可以把红链接/黑链接信息放入这些bits中，而不用占用一个数据成员。而SkipList一目了然，可以直接用一个指针数组+value数据成员构成一个节点。
- 红黑树在进行2-3-4树的自顶向下分裂4-节点过程中，除了改变链接的红黑属性，更需要旋转。在需要一次或者二次旋转的情况下，红黑树结构需要至少操作4个链接。而这种操作，是自顶向下的，分裂一切在插入过程中遇到的4-节点，这就需要操作4(1 ~ lgN+1)个链接。而SkipList呢，需要以p^i的概率操作2(i+1)个链接。相比之下，少了很多。

![](/images/2014-03-31-5_7-0.jpg)

综上，从容易实现的角度，从多核并行的角度，SkipList容易实现。如果从搜索性能来看，还是红黑树和伸展BST比较好。

**最坏情况**

如果跳跃表产生概率P的部分工作不正常，导致跳跃表高度很低，近似于一个双向链表和少量几个高层次链接。那么SkipList就没有了所谓的“快速跑道”也就不再是“快速穿越链表”。时间复杂度为链表复杂度O(n)。

**一般情况**

设SkipList高度为M，则从L(M-1),L(M-2),...,L(2),L(1)层往下搜索过程中，每次需要从当前位置先往 *下* 走一步，再往 *F orword* 方向比较t次（t = 1/p，快速穿越链表平均每t个节点就要有一个节点SkipListNode Level增加一层）。

L(i) = N(p^i-1) = N/(t^i-1)，L(i)表示第i层有L(i)个节点。  
则设S(i)为第i层的平均访问次数，  
显然S(i) = t/2 （有疑问，或许是 (t+1)/2 ?）  

![](/images/2014-03-31-5_7-1.gif)

![](/images/2014-03-31-5_7-2.gif)

![](/images/2014-03-31-5_7-3.gif)

所以，时间复杂度为O( (1/p)log(1/p)^N ) = O(tlogt^N)。

平均情况下，**在参数为t的随机化跳跃表中进行搜索和插入操作需要大约 (t logt^N)/2** = (t/2 lgt)lgN 次比较。  
即时间复杂度为**O(t logt^N)**。

![](/images/2014-03-31-5_7-5.jpg)

既然算了，干脆说下空间复杂度吧。  
所有层节点之和等于S，

![](/images/2014-03-31-5_7-4.gif)

因此，**空间复杂度为O(N)**。

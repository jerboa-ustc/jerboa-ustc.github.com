---
layout: post
title: APUE笔记：进程运行环境 进程布局 变量类型
categories:
- APUE
tags:
- APUE笔记
---

**1 C程序执行**

内核使程序执行的唯一方法是调用一个exec函数。在调用main函数前先调用一个特殊的*启动例程* 。可执行程序文件将此启动例程指定为此程序的起始地址。启动例程从内核获取*命令性参数和环境变量表*，然后为执行main函数做好准备。

{% highlight c++ %}
int main(int argc, char *argv[])
{% endhighlight %}

**2 进程终止**

**exit**

进程资源终止唯一方法是显示或隐式的调用（通过调用exit）_exit或_Exit，进程科也可以非自愿的由一个信号使其终止。

exit与\_exit/\_Exit的区别是，会先执行一些清理处理(执行各个exit handler，并关闭所有标准I/O流)，然后进入内核。

**atexit**

终止处理程序（exit handler）由exit自动调用，且调用顺序和handler注册顺序*相反* 。

![](/images/2014-05-07-2-1.PNG)

**3 环境表**

每个程序都会有一张环境表，与参数表argv[]一样，环境表也是一个字符指针数组，每个指针指向环境字符串。全局变量environ指向了该表。

![](/images/2014-05-07-3-1.PNG)

**4 进程存储空间布局**

关于布局不多说，以后把onenote上的笔记上传，APUE这节说的不是很详细。

值得注意的是环境变量表在空间布局上的限制。

因为环境表和环境字符串通常占用的是进程地址空间的顶部，所以他不能在向高地址方向（向上）扩展；同时也不能易懂在它之下的各个栈帧，所以也不能向低地址方向（向下）扩展。两者组合使得该空间的长度不能再增加，即*不能再原空间上（栈帧）增加环境变量项*。  
那么怎么增加呢？很简单，首先malloc为新环境字符串申请空间；然后使用malloc为新的指针表分配空间，将原来的指针表复制到新空间上，并在表尾增加一项指针，指向刚才新的环境字符串，最后表最后放置一个空指针；最后更新envrion指针，指向堆上的新表。

如果不是第一次扩展环境表，则表已经在堆上了，所以直接remalloc即可。

**5 关于setjmp与longjmp**

Cont.

**6 自动、寄存器变量，全局变量，静态变量，易失变量**

全局，静态和易失变量不收编译器优化影响，总是从Mem中存取。而自动，寄存器变量在优化后存储在寄存器中。

所以如果要使用非局部跳转的可移植程序，必须使用volatile属性，使之总是从Mem中存取。

在APUE 7-6示例中，调用longjmp之前对各个变量均有第二次赋值，调用longjmp之后栈帧回到调用setjmp时的样子。这时autoval,regival由于编译器优化其值从寄存器取出，所以是第一次赋值时的值，而其余vollval，statval，globval均从Men取值，是第二次的值。
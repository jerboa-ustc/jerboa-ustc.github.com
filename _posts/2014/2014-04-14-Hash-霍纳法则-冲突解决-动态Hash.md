---
layout: post
title: Hash 霍纳法则 冲突解决 动态Hash
categories:
- Hash
tags:
- Hash
- Horner法则
---

1 **Horner法则**

给一个字符串“averylongkey”，我们怎么计算出hash key呢？肯定是想让串的每一个字符都参与运算而产生一个key，这样才会使冲突概率变小。然而（如手画图1）所示，这种运算对于一般的串，其运算结果都显得太大了，而且+与\*与10^n运算缓**慢**。

如果我们执意要取得这种效果并且要快速得到答案怎么办？[“霍纳法则”](http://www.cnblogs.com/nufangrensheng/p/3633493.html)，霍纳使得MOD与幂运算可以有另一种排列方式，虽然展开后都是一样的，可是这种排列使得运算在"递归"和“迭代”中运算的非常**快**（如手画图2）。

MOD运算为何能使用Honner

{% highlight c++ %}
(((ax) mod M) + b) mod M = (ax + b) mod M
{% endhighlight %}

一个一般性**字符串Hash**，使用**Honner法则**迭代

{% highlight c++ %}
//M是表长（如果采用下列，则M是不是素数都无关紧要了），src为串，h记录上次运算后的余数
//	a为基数通常是一个素数，如果严格按照上述公式a = 28，
//		因为128是字符串转10进制的基数，这里为了较好的HASH性能，a变成了一个素数
int hash(char *src, int M)
{
	int h = 0, a = 127;
	for(; *src != '\0'; src++)
	{
		h = (a*h + *src) % M;
	}
	return h;
}
{% endhighlight %}

改进

{% highlight c++ %}
//M是表长（如果采用下列，则M是不是素数都无关紧要了），src为串，h记录上次运算后的余数
//	a为基数通常是一个素数，如果严格按照上述公式a = 28，
//		因为128是字符串转10进制的基数，这里为了较好的HASH性能，a变成了一个素数
int hash(char *src, int M)
{
	int h = 0, a = 31415, b = 27183;
	for(; *src != '\0'; src++, a = a*b % (M-1))
	{
		h = (a*h + *src) % M;
	}
	return h;
}
{% endhighlight %}

一些常用的hash

对于介于(s, t)之间的浮点数v

{% highlight c++ %}
#define hash(v, M) (((v-s)/(t-s))*M) 
{% endhighlight %}

对于整数

{% highlight c++ %}
#define hash(v, M) (((int)(0.616161) * (float)v) % M) 
#define hash(v, M) ((16161 * (unsigned)v) % M) 
{% endhighlight %}

或者最省事的方式：按位与  

{% highlight c++ %}
//M是2^n
#define hash(v, M) (v & (M-1))
{% endhighlight %}

2 **冲突**

2.1 **链地址**

链地址是什么就不说了。通常链地址法里面采用的都是**无序链表**和**头插法**。

如果我们使用无序链表和头插入，有两个优势：a.插入很快；b.链表类似于栈，可以直接找到刚才插入的节点

如果使用有序链表，可以使搜索加快一倍。不成功的搜索无序表需要遍历整个表，有序表平均需要遍历一半长度。

通常呢，M的大小被设定为关键字数目N的1/10或者1/5，这样，每个冲突地址的链表包含的节点为5~10个。

关于**无序表**，**STL中的hash_set**用的也是它，可能是有序导致的插入开销太大而搜索提升较小，得不偿失吧。

MoreWindows的一个文章中[STL系列之九 探索hash_set](http://blog.csdn.net/morewindows/article/details/7330323)，测试了下hash_set和map，据博主所说他的版本比STL的要快。我猜可能是STL考虑了空间不够时扩充的情况。

这个是MoreWin插入500W时的统计。  
> “长度为1和长度为2的链表中的数据占全部数据的89%以上。因此绝大数查询将仅仅访问哈希表1次到2次。”

![](/images/2014-04-14-2_1-1.gif)

2.2 **线性探测**

一句话，线性探测就是插入地址非空则继续往后偏移1个地址继续找空的“坑”。

{% highlight c++ %}
void Insert(Type item)
{
	Key v = key(item);
	int i = hash(v, M);
	while(!null(i))
		i = (i+1) % M;
	HashTable[i] = item;
}

Type Search(Key v)
{
	int i = hash(v, M);
	while(!null(i))
		if(eq(v, key(HashTable[i])))
			return HashTable[i];
		else
			i = (i+1) % M;
	return NULLitem;
}
{% endhighlight %}

线性探测一个不好的地方就是**聚集**，非常烦人,聚集影响着搜索和删除。我们假设要进行m次搜索，搜索恰好在一个聚集中，聚集大小是t长度。那么总的探测次数为，
(t+(t-1)+...+2+1)/m = t(t+1)/2m ，**搜索失败**平均次数与聚集大小t的平方成正比，**O(t^2)**。

删除，在有聚集的情况下删除，需要往前挪动一位指定元素之后所有在聚集内的元素。

{% highlight c++ %}
void delete(Type item)
{
	int i, j;	Type temp;
	i = hash(key(item), M);
	while(!null(i))
		if(eq(key(item), key(HashTable[i])))
			break;
		else
			i = (i+1) % M;
	if(null(i))
		return;
	HashTable[i] = NULLitem;
	for(j = i+1; !null(j); j = (j+1)%M)
	{
		temp = HashTable[j];
		HashTable[j] = NULLitem;
		insert(temp);
	}
}
{% endhighlight %}
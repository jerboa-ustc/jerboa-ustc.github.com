---
layout: post
title: Hash 霍纳法则 冲突解决 动态Hash
categories:
- Hash
tags:
- Hash
- Horner法则
---

1 **Horner法则**

给一个字符串“averylongkey”，我们怎么计算出hash key呢？肯定是想让串的每一个字符都参与运算而产生一个key，这样才会使冲突概率变小。然而（如手画图1）所示，这种运算对于一般的串，其运算结果都显得太大了，而且+与\*与10^n运算缓**慢**。

如果我们执意要取得这种效果并且要快速得到答案怎么办？[“霍纳法则”](http://www.cnblogs.com/nufangrensheng/p/3633493.html)，霍纳使得MOD与幂运算可以有另一种排列方式，虽然展开后都是一样的，可是这种排列使得运算在"递归"和“迭代”中运算的非常**快**（如手画图2）。

MOD运算为何能使用Honner

{% highlight c++ %}
(((ax) mod M) + b) mod M = (ax + b) mod M
{% endhighlight %}

一个一般性**字符串Hash**，使用**Honner法则**迭代

{% highlight c++ %}
//M是表长（如果采用下列，则M是不是素数都无关紧要了），src为串，h记录上次运算后的余数
//	a为基数通常是一个素数，如果严格按照上述公式a = 28，
//		因为128是字符串转10进制的基数，这里为了较好的HASH性能，a变成了一个素数
int hash(char *src, int M)
{
	int h = 0, a = 127;
	for(; *src != '\0'; src++)
	{
		h = (a*h + *src) % M;
	}
	return h;
}
{% endhighlight %}

改进

{% highlight c++ %}
//M是表长（如果采用下列，则M是不是素数都无关紧要了），src为串，h记录上次运算后的余数
//	a为基数通常是一个素数，如果严格按照上述公式a = 28，
//		因为128是字符串转10进制的基数，这里为了较好的HASH性能，a变成了一个素数
int hash(char *src, int M)
{
	int h = 0, a = 31415, b = 27183;
	for(; *src != '\0'; src++, a = a*b % (M-1))
	{
		h = (a*h + *src) % M;
	}
	return h;
}
{% endhighlight %}

一些常用的hash

对于介于(s, t)之间的浮点数v

{% highlight c++ %}
#define hash(v, M) (((v-s)/(t-s))*M) 
{% endhighlight %}

对于整数

{% highlight c++ %}
#define hash(v, M) (((int)(0.616161) * (float)v) % M) 
#define hash(v, M) ((16161 * (unsigned)v) % M) 
{% endhighlight %}

或者最省事的方式：按位与  

{% highlight c++ %}
//M是2^n
#define hash(v, M) (v & (M-1))
{% endhighlight %}

2 **冲突**

2.1 **链地址**

链地址是什么就不说了。通常链地址法里面采用的都是**无序链表**和**头插法**。hash bucket的一种实现方式。

如果我们使用无序链表和头插入，有两个优势：a.插入很快；b.链表类似于栈，可以直接找到刚才插入的节点

如果使用有序链表，可以使搜索加快一倍。不成功的搜索无序表需要遍历整个表，有序表平均需要遍历一半长度。

通常呢，M的大小被设定为关键字数目N的1/10或者1/5，这样，每个冲突地址的链表包含的节点为5~10个。

关于**无序表**，**STL中的hash_set**用的也是它，可能是有序导致的插入开销太大而搜索提升较小，得不偿失吧。

MoreWindows的一个文章中[STL系列之九 探索hash_set](http://blog.csdn.net/morewindows/article/details/7330323)，测试了下hash_set和map，据博主所说他的版本比STL的要快。我猜可能是STL考虑了空间不够时扩充的情况。

这个是MoreWin插入500W时的统计。  
> “长度为1和长度为2的链表中的数据占全部数据的89%以上。因此绝大数查询将仅仅访问哈希表1次到2次。”

![](/images/2014-04-14-2_1-1.gif)

2.2 **线性探测**

一句话，线性探测就是插入地址非空则继续往后偏移1个地址继续找空的“坑”。

{% highlight c++ %}
void Insert(Type item)
{
	Key v = key(item);
	int i = hash(v, M);
	while(!null(i))
		i = (i+1) % M;
	HashTable[i] = item;
}

Type Search(Key v)
{
	int i = hash(v, M);
	while(!null(i))
		if(eq(v, key(HashTable[i])))
			return HashTable[i];
		else
			i = (i+1) % M;
	return NULLitem;
}
{% endhighlight %}

线性探测一个不好的地方就是**聚集**，非常烦人,聚集影响着搜索和删除。我们假设要进行m次搜索，搜索恰好在一个聚集中，聚集大小是t长度。那么总的探测次数为，
(t+(t-1)+...+2+1)/m = t(t+1)/2m ，**搜索失败**平均次数与聚集大小t的平方成正比，**O(t^2)**。

删除，在有聚集的情况下删除，需要往前挪动一位指定元素之后所有在聚集内的元素。

{% highlight c++ %}
void delete(Type item)
{
	int i, j;	Type temp;
	i = hash(key(item), M);
	while(!null(i))
		if(eq(key(item), key(HashTable[i])))
			break;
		else
			i = (i+1) % M;
	if(null(i))
		return;
	HashTable[i] = NULLitem;
	for(j = i+1; !null(j); j = (j+1)%M)
	{
		temp = HashTable[j];
		HashTable[j] = NULLitem;
		insert(temp);
	}
}
{% endhighlight %}

2.3 **双重散列**

为了得到更少的聚集和更小的聚集，我们使用双重散列。由冲突而引起的Hash地址增量变成了k（k由二次hash计算得出，而不是简单地为1）。

这种方式下，**一个特定地址冲突引起的各个散列元素就不再是只存在于一个聚集中（2.2节中，一个指定地址发生冲突，则由此引发的开放地址都在一个聚集中，不会出现在其他聚集）。**

由此引出一个结论，**2.2节中的删除不能用于双重散列**。因为不能保证当前聚集中拥有所有由当前地址引发的开放地址。只能在要删除的地址上做标记，**标记非空且无效**。

二次hash得到的增量k必须与表大小互素，否则可能会引发死循环。如果k为M的因子，可能导致不停的尝试在表中几个地址循环的查找是否可插入，而如果这几个地址都已经非空，则一定会出现死循环。

通常二次hash都很简单，如

{% highlight c++ %}
#define hashtwo(v, M) ((v % 97)+1)
{% endhighlight %}

如果保证装填因子对于**线性探测**和**双重散列**算法分别小于![](/images/2014-04-14-2_3-1.gif)和![](/images/2014-04-14-2_3-2.gif)，那么搜索的平均开销**小于t次**探测。

2.4 **动态散列**

简单的动态散列是，

- 当表中元素多余表大小M的1/2时，进行一次倍增。这时需要将所有非空地址中的元素取出重新散列。
- 当表中元素少于表达小M的1/4时，进行一次减半。同样需要重新散列所有元素。

进过上述处理，可以让表中元素数目始终为表大小M的1/8~1/2 。

STL中的散列是可扩展的。

2.5 **常用的hash过程**

**DJB（DJBX33A）哈希算法**

DJB很简单，却可以保证很低的冲突概率。以下是核心代码，可以看到同样使用了Horner法则：循环计算nHash = nHash\*33 + \*key++。

{% highlight c++ %}
public static uint DJBHash(string value)
{
    if (string.IsNullOrEmpty(value))
    {
        throw new ArgumentNullException("The hash value can't be empty.");
    }

    uint hash = 5381;
    for (int i = 0; i < value.Length; i++)
    {
        // The value of ((hash << 5) + hash) the same as 
        // the value of hash * 33.
        hash = ((hash << 5) + hash) + value[i];
    }

}
{% endhighlight %}

**暴雪哈希算法**

另一个更高效的hash算法是网上流传很久的[暴雪hash](http://www.oschina.net/code/snippet_99767_1217)。这个hash过程，仅仅存贮3个hash值，pos = hash % tableSize。第一个hash值用于找地址pos，第二个第三个hash值hashA-hashB用于“指纹”，即table中不在存贮字串用以冲突时对比，而是对比hashA-hashB。若三者相同且存在，则找到指定的字串。

值得一提的是，暴雪hash在生成hash的时候，用了一张精心设计的伪随机数表cryptTable[1280]，来生成3个hash值。

{% highlight c++ %}
/*函数名：Hash
/*功  能：hash一个字符串 
/*返回值：成功，返回true；失败，返回false
bool StringHash::Hash(string lpszString)
{  
	const unsigned long HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;  
	unsigned long nHash = HashString(lpszString, HASH_OFFSET);  
	unsigned long nHashA = HashString(lpszString, HASH_A);  
	unsigned long nHashB = HashString(lpszString, HASH_B);  
	unsigned long nHashStart = nHash % m_tablelength, 
		nHashPos = nHashStart;  

	while ( m_HashIndexTable[nHashPos].bExists)  
	{   
		nHashPos = (nHashPos + 1) % m_tablelength;  
		if (nHashPos == nHashStart) //一个轮回  
		{  
			//hash表中没有空余的位置了,无法完成hash
			return false;   
		}  
	}  
	m_HashIndexTable[nHashPos].bExists = true;  
	m_HashIndexTable[nHashPos].nHashA = nHashA;  
	m_HashIndexTable[nHashPos].nHashB = nHashB;  

	return true;  
}  
{% endhighlight %}

不知道33为什么被大家都采用，暴雪hash里面计算seed也有一个\*33过程：seed2 + (seed2 << 5)。  
> *41不好吗？41 = 42-1,42可是宇宙的终极答案！深蓝运算了1000W年才计算出来42这个结果。*

2.6 **hash攻击**

hash攻击的思路都是一个：构造冲突字串，让hash表退化成一个类单链表，这样查找就变成了O(n)复杂度。

**等效字串**

[等效字串](http://www.cnblogs.com/rush/archive/2012/02/05/2339037.html)解释在这里。

网摘：  
> 如果哈希函数具有这样的特性，当两个字符串的哈希值发生冲突，例如：hash(“string1”)=hash(“string2”)，那么由这两个子串在同一位置上构成的字符串也发生哈希冲突，例如：hash(“prefixstring1postfix”)=hash(“prefixstring2postfix”)。

**中途相遇攻击（不明白）**

[中途](http://www.cnblogs.com/rush/archive/2012/02/05/2339037.html)也是一个等效字串攻击。只不过加快了寻找字串的过程。本菜没看懂此过程中计算出前缀字串和后缀字串，为什么拼起来就能够造出冲突字符串？

博客的结论  
> “假设我们找到前缀“BIS”，而且HashBack(“NBJ”) = 147958270，然后我们通过暴力方法找出了和前缀有冲突的后缀Hash(“SKF0FTG”) = 147958270，接着我们把它们拼接起来计算Hash(“NBJ” + “SKF0FTG”) = 6888888，我们看到拼接起来的字符串计数出来的哈希值是我们事先已经指定好的，所以我们可以通过这种方法不断构造冲突数据。  
接着我们使用以上的冲突数据进行插入测试，一开始运行插入数据CPU的消耗就开始变得大了，曾经一度消耗到100%那时机器根本动不了，所以无法截图。”
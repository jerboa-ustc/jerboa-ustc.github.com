---
layout: post
title: 递归遍历UFS层次结构
categories:
- APUE
tags:
- UNIX文件系统
- APUE笔记
---

jerboa：今天看完了APUE前6章，觉得APUE 4-7这个示例写的非常好，简短并且易懂，风格类似sedgewick介绍数据结构和上课时写的示例一样。  
自己将APUE 4-7示例稍作修改，并且在输出时参考了[这篇文章](http://blog.chinaunix.net/uid-10106787-id-3035688.html)中的打印函数pr_fname，用以增加一个类似tree命令的功能。

**1 效果**

![](/images/2014-05-06-1-1.PNG)

**2 代码解析**

**程序流程**

1. 给main函数输入指定起始目录，调用callee0对起始目录进行递归分析、统计文件类型/文件个数/目录个数，最后打印统计信息/输出tree结构图
2. callee0对main函数传递来的起始目录进行预处理：为可能的路径字符串分配足够大的向量（这里自己用的是1024或者预定义长度），为防止出错将向量fullpath中最后以字节设为0，调用callee1对fullpath中原始目录进行递归统计、分析
3. callee1是核心过程。
	1. 首先判断目录是否可读，若不能用lstat函数填充statbuf字段，则抛给callee2打印出错信息并返回0
	2. 接着判断目录是否是一个文件，若不是目录则调用callee2，使用st\_mode & S\_LFMT判断其文件类型（普通文件/2种特殊设备文件/FIFO文件/硬链接文件/SOCKECT套接字/目录文件(表示为目录文件显然创建时出错了) ），统计
	3. 最后，如果是一个目录分两步：
		1. 先统计此目录信息
		2. 使用树或者图的DFS**深度优先遍历**方法，递归的读取当前目录的子目录项，并且进行信息统计
- 上述所有统计的具体工作均由callee2完成。callee2用caller传递来的FTW\_XXX信息和st\_mode & S_LFMT信息进行统计计数，并且打印当前文件/目录相对路径字符串。

**杂七杂八说明**

读指定目录的目录项用的是APUE简易ls上的流程：opendir，readdir，closedir。

callee2被调用时caller使用了函数指针来调用函数。

APUE中callee1：dopath函数在DFS深度优先遍历过程中使用了这样一句：

{% highlight c++ %}
if((ret = dopath(func)) != 0)   /* recursive */
	break;                  /* time to leave */
{% endhighlight %}

但是呢，jerboa不明白为什么会有callee1：dopath函数返回值不为0的情况。改为如下也行啊：

{% highlight c++ %}
ret = dopath(func)
{% endhighlight %}

**3 C-code**

{% highlight c++ %}
/*************************************************************************
	> File Name: apue_tree.c
	> Author: jerboa
	> Mail: a.jerboa@gmail.com
	> Created Time: 2014年05月06日 星期二 14时04分12秒
 ************************************************************************/

#include <stdio.h>
#include "apue.h"
#include <dirent.h>
#include <limits.h>

typedef int MyFunc(const char*, const struct stat*, int, int);
static MyFunc myfunc;
static int MyFtw(char *, MyFunc*);
static int dopath(MyFunc*);
static void print_fname(const char *, int);
static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;
static char *fullpath;
static int depth;

#define FTW_F 1
#define FTW_D 2
#define FTW_DNR 3
#define FTW_NS 4

#ifdef PATH_MAX
	const int PATH_LEN = PATH_MAX;
#else
	const int PATH_LEN = 1024;
#endif

#define END(s) ((char *)(s) + strlen(s))

int main(int argc, char* argv[])
{
	int ret;
	if(argc != 2)
		err_quit("usage: ftw <starting-pathneme");
	
	ret = MyFtw(argv[1], myfunc);	/* start dfs dirs*/

	ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock + ntot;

	if(ntot == 0)
		ntot = 1;
	printf("regular files	= %7ld, %5.2f %%\n", nreg, nreg*100.0/ntot);
	printf("directories		= %7ld, %5.2f %%\n", ndir, ndir*100.0/ntot);
	printf("block special	= %7ld, %5.2f %%\n", nblk, nblk*100.0/ntot);
	printf("char special	= %7ld, %5.2f %%\n", nchr, nchr*100.0/ntot);
	printf("FIFOs			= %7ld, %5.2f %%\n", nfifo, nfifo*100.0/ntot);
	printf("symbolic links	= %7ld, %5.2f %%\n", nslink, nslink*100.0/ntot);
	printf("sockets			= %7ld, %5.2f %%\n", nsock, nsock*100.0/ntot);

	exit(0);
}

static int MyFtw(char *pathname, MyFunc *func)
{
	int ret;

	fullpath = malloc(PATH_LEN);

	strncpy(fullpath, pathname, PATH_LEN);
	fullpath[PATH_LEN-1] = '\0';

	ret = dopath(func);
	free(fullpath);
	return(ret);
}

static int dopath(MyFunc* func)
{
	struct stat statbuf;
	struct dirent *dirp;
	DIR *dp;
	int ret;
	char *ptr;

	if(lstat(fullpath, &statbuf) < 0)	/*stat error*/
		return (func(fullpath, &statbuf, FTW_NS, depth));
	if(S_ISDIR(statbuf.st_mode) == 0)	/*not a dir*/
		return (func(fullpath, &statbuf, FTW_F, depth));

	/*now, we got a real dir*/
	if((ret = func(fullpath, &statbuf, FTW_D, depth)) != 0)	/*unknown counter error*/
		return ret;

	ptr = END(fullpath);
	*ptr++ = '/';
	*ptr = '\0';

	if((dp = opendir(fullpath)) == NULL)	/*cant read a dir*/
		return(func(fullpath, &statbuf, FTW_DNR, depth));
	
	depth++;

	while((dirp = readdir(dp)) != NULL)
	{
		if( strcmp(dirp->d_name, ".")==0 || strcmp(dirp->d_name, "..")==0 )
			continue;

		strcpy(ptr, dirp->d_name);	/*dfs, append a sub dir name*/
		
		if((ret = dopath(func)) != 0)	/*不明白为什么会有！=0 的情况发生，这里直接dppath(func)也可以*/
			break;
	}
	ptr[-1] = 0;
	
	depth--;

	if(closedir(dp) < 0)
		err_ret("cant close this dir %s", fullpath);

	return(ret);
}

static int myfunc(const char* pathname, const struct stat *statptr, int type, int depth)
{
	switch (type)
	{
		case FTW_F:
			switch (statptr->st_mode & S_IFMT)
			{
				case S_IFREG:	nreg++;		break;
				case S_IFBLK:	nblk++;		break;
				case S_IFCHR:	nchr++;		break;
				case S_IFIFO:	nfifo++;	break;
				case S_IFLNK:	nslink++;	break;
				case S_IFSOCK:	nsock++;	break;
				case S_IFDIR:
								err_dump("directory should have type FTW_D, %s.", pathname);
			}
			break;
		case FTW_D:
			ndir++;
			break;
		case FTW_DNR:
			err_ret("cant read this dir %s", pathname);
			break;
		case FTW_NS:
			err_ret("stat error for %s", pathname);
			break;
		default:
			err_dump("unknown type %d for pathname %s", type, pathname);
	}
	
	print_fname(pathname, depth);
	return (0);
}

static void print_fname(const char *pathname, int depth)
{
	int i=0, dep=0;
	for(; i<depth*4 - 1; i++)
	{
		if(!(i & 3))
		{
			printf("|");
			if(i) dep++;
		}
		if(dep + 1 == depth)
			printf("-");
		else
			printf(" ");
	}
	printf(" %s\n", pathname);
}

{% endhighlight %}
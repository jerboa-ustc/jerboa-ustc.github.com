---
layout: post
title: 全排列 字典序
categories:
- 排列
- Algorithms
tags:
- 一致性
- Hash
- 失效
---

**字符串的全排列/组合**

今天看到一个全排列问题：“字符串的排列”，然后看到一个解法是“**字典序**排列”。以前没有见过，现在记录下来。

字典序是C++ STL算法next_permutation实现。作为一个非递归算法，本菜觉得这种方法和**DFS**都是比较好的。

**字典序法**：

来自这篇,[字典序全排列算法研究。](http://www.cnblogs.com/pmars/p/3458289.html)

对给定的字符集中的字符规定了一个先后关系，在此基础上规定两个全排列的先后是从左到右逐个比较对应的字符的先后。

算法过程：  
{% highlight c++ %}
//【例】 一般而言，设P是[1,n]的一个全排列。
//　　　　　　P=P1P2…Pn=P1P2…Pj-1PjPj+1…Pk-1PkPk+1…Pn
//　　　　find:　　j=max{i|Pi<Pi+1}
//　　　　　　　　　k=max{i|Pi>Pj}
//　　　　　　1，  对换Pj，Pk，
//　　　　　　2，  将Pj+1…Pk-1PjPk+1…Pn翻转
 //         P’= P1P2…Pj-1PkPn…Pk+1PjPk-1…Pj+1即P的下一个
{% endhighlight %}

{% highlight  %}
//【例】 如何得到346987521的下一个
 //   1，从尾部往前找第一个P(i-1) < P(i)的位置
//4 6 <- 9 <- 8 <- 7 <- 5 <- 2 <- 1
//        最终找到6是第一个变小的数字，记录下6的位置i-1
//    2，从i位置往后找到最后一个大于6的数
//4 6 -> 9 -> 8 -> 7 5 2 1
//        最终找到7的位置，记录位置为m
//    3，交换位置i-1和m的值
//4 7 9 8 6 5 2 1
//    4，倒序i位置后的所有数据
//4 7 1 2 5 6 8 9
//    则347125689为346987521的下一个排列
{% endhighlight %}

{% highlight c++ %}
private static void PermutationList()
        {
            int fromIndex, endIndex, changeIndex;
            Sort(0, length - 1);
            do
            {
                // 输出一种全排列
                Output();
                fromIndex = endIndex = length - 1;
                // 向前查找第一个变小的元素
                while (fromIndex > 0 && words[fromIndex] < words[fromIndex - 1]) --fromIndex;
                changeIndex = fromIndex;
                if (fromIndex == 0) break;
                // 向后查找最后一个大于words[fromIndex-1]的元素
                while (changeIndex + 1 < length && words[changeIndex + 1] > words[fromIndex - 1]) ++changeIndex;
                Swap(fromIndex - 1, changeIndex);   // 交换两个值
                InvertArray(fromIndex, endIndex);   // 对后面的所有值进行反向处理
            } while (true);
        }
{% endhighlight %}

虽然这种方法很不错，但是还是不如DFS容易写出来，while循环条件判断写的烦死了。

**深度优先遍历法**

全排列  
设有字符串srt[]。
{% highlight c++ %}
void perm(int str[], int l, int r)
{
	if (l > r)
	{
		display(str);
	}
	for (int i=l; i<=r; i++)
	{
		swap(str[l], str[i]);		//i已访问
		perm(str, l+1, r);
		swap(str[l], str[i]);		//i未访问
	}
}

//main:		perm(str, 0, strlen(str)-1);
{% endhighlight %}

组合  
{% highlight c++ %}
const int N = strlen(str);
int *X = (int\*)malloc(N);
memset(str,0,N);

void DFS(int depth)
{
	if(depth > N)
	{
		for(int i=0; i<N; i++)
		{
			if(X[i])
				cout<<str[i];
		}
		cout<<endl;
		return;
	}
	//要或者不要两种
	X[depth] = 0;		//不要
	DFS(depth+1);
	X[depth] = 1;		//要
	DFS(depth+1);
}
//main		DFS(0);
{% endhighlight %}
---
layout: post
title: 企鹅实习生笔试总结（cont.）
categories:
- internship
---

jerboa：昨天参加了企鹅的实习生笔试，我觉得自己的基础还是不够好。继续打补丁吧！

**1 OS相关的题目**

**1.1 ls命令使用到的syscalls**

{% highlight Bash shell scripts %}
原题是：*“ ls命令使用了哪些系统调用？ A. read  B. open c. fork  d. mmap ”*
{% endhighlight %}

这题考察了shell的内建命令和外部命令。

网络摘抄：  
*Linux命令的执行必须依赖于Shell命令解释器。Shell实际上是在Linux系统中运行的一种特殊程序，它位于操作系统内核与用户之间，负责接受用户输入的命令并进行解释，将需要执行的操作传递给系统内核执行，Shell在用户和内核之间充当了一个“翻译官”的角色。当用户登陆到Linun系统时，会自动加载一个Shell程序，以便给用户提供可以输入命令的操作环境。
Bash是Linux系统中默认使用的Shell程序，文件位于/bin/bash。*

根据Linux命令与Shell程序的关系，一般分为以下3种类型：  

**内建命令**：
内建命令就是由Shell本身所执行的命令。  
指的是集成于Shell解释器程序（如Bash）内部的一些特殊指令，也成为内建（Built-IN)指令。内部命令属于Shell的一部分，所以并没有单独对应的系统文件，只要Shell解释器被运行，内部指令也就自动载入内存了，用户可以直接使用。内部命令无需从硬盘中重新读取文件，因此执行效率更高

**外部命令**：
指的是Linux系统中能够完成特定功能的脚本文件或二进制程序，每个外部命令对应了系统中的一个文件，是属于Shell解释器程序之外的命令，所以称为外部命令。Linux系统必须知道外部命令对应的文件位置，才能够由Shell加载并执行。  
Linux系统默认会将存放外部命令、程序的目录（如/bin、/usr/bin、/usr/local/bin等）添加到用户的“搜索路径”中，当使用位于这些目录中的外部命令时，用户不需要指定具体的位置。因此在大多数情况下，不用刻意去分辨内部、外部命令，其使用方法是基本类似的。

**shell函数**：
Shell函数是功能健全的一系列程序代码，以Shell语言写成，它们可以像命令那样引用。

如何分辨内部、外部命令？

*使用 type可以查看是否是内建命令:  
type (不带参数)会显示命令是内建命令还是外部命令  
-t :file 外部命令;alias 命令别名;builtin 内置命令  
-a :会将命令PATH路径显示出来*  
*使用 sudo XXX，如sudo ls。原因是，build-in 命令不能用 sudo ...例如 cd 命令。*

**用户在命令行输入命令后，一般情况下外部命令Shell会fork并exec该命令，但是Shell的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不创建新的进程。**

这篇文章展示了ls的实现，调用了哪些syacalls[ls的实现](http://www.cppblog.com/momoxiao/archive/2010/04/04/111594.html)。

假设当前目录在ext2文件系统上，ls要查看当前目录下的文件，归纳下ls执行的整个流程：

- open打开当前目录的句柄，这个句柄对应内核中一个file结构。
   file结构中的file_operations函数集从inode结构中获得，就是ext2_file_operations
- getdents64调用file->f_op->readdir()实际上是调用了ext2_file_operations中的readdir()，
   由ext2文件系统驱动读取当前目录下面的文件项。

我们要隐藏一个文件，要做的就是替换file->f_op->readdir()，也就是替换ext2_file_operations中的readdir()。

**2 稀疏矩阵存贮**

稀疏矩阵的压缩存储有几种方式，如：三元组顺序表、行逻辑链接的顺序表和十字链表。

三元组表示法就是在存储非零元的同时，存储该元素所对应的行下标和列下标。稀疏矩阵中的每一个非零元素由一个三元组(i,j,aij)唯一确定。如图

![](/images/2014-04-21-2-1.jpg)

行逻辑链接，加入一个行表来记录稀疏矩阵中每行的非零元素在三元组表中的起始位置。就是三元组表示法的一个优化。

十字链表，如图

{% highlight c++ %}
typedef struct OLNode {  
     int  i, j;          //行号与列号   
     ElemType e;        //值   
     struct OLNode *right, *down;  //指针域   
}OLNode, *OList;

typedef struct {  
    OLink   *Rhead, *Chead;   
    int mu, nu, tu;       // 稀疏矩阵的行数、列数和非零元个数    
}CrossList;  
{% endhighlight %}

![](/images/2014-04-21-2-2.gif)

**3 进程通信**

不多说了，竟然没想起来有名管道就是FIFO，略蛋疼。

{% highlight Bash shell scripts %}
8. Unix系统中，适合任意两个进程通信的是（）

A FIFO  B  PIPE  C Message Queue  D  sharememory
{% endhighlight %}

这题应该选 A-C-D。

[Linux进程间通信之管道(pipe)、命名管道(FIFO)与信号(Signal)](http://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html)

**ADT**

这题也错了，真是千疮百孔。

常用的线性结构有：**线性表，栈，队列，循环队列，数组。线性表中包括顺序表、链表等**。

**Mem内零头、外零头**

{% highlight Bash shell scripts %}
在存储管理中，内零头是指分配给作业的存储空间中未被利用的部分，外零头是指系统中无法利用的小存储块。

在页式虚拟存储系统中，用户作业的地址空间被划分成若干大小相等的页面，存储空间也分成也页大小相等的物理块，但一般情况下，作业的大小不可能都是物理块大小的整数倍，因此作业的最后一页中仍有部分空间被浪费掉了。由此可知，页式虚拟存储系统中存在内零头。

在段式虚拟存储系统中，作业的地址空间由若干个逻辑分段组成，每段分配一个连续的内存区，但各段之间不要求连续，其内存的分配方式类似于动态分区分配。由此可知，段式虚拟存储系统中存在外零头。
{% endhighlight %}

**send发送大量小数据包**

答案不知道。

{% highlight Bash shell scripts %}
16 使用 send发送大量小的数据包，说法正确的是（）
A 带宽利用率低 B 网卡吞吐很高 C 网卡中断频繁 D 进程上下文切换频繁
{% endhighlight %}

**数据库索引**

答案不知道。

{% highlight Bash shell scripts %}
23 数据索引的正确是（）
A 1个表只能有一个聚族索引，多个非聚族索引
B 字符串模糊查询不适合索引     //自认为B是对的，但是不确定，待解答
C 哈希索引有利于查询字段用于大小范围的比较查询
D 多余的索引字段会降低性能
{% endhighlight %}

**CPU与外设数据传输**

不知道答案。DMA算不算呢，毕竟DMA是绕过了CPU。

{% highlight Bash shell scripts %}
24 CPU与外设的传输数据的方式是（）
A 程序方式 B中断 C DMA D 通道方式 
{% endhighlight %}

**MySql**

{% highlight Bash shell scripts %}
26. MySQL中表test选择10条到20条记录的语句是______
{% endhighlight %}

**MapReduce过程**

{% highlight Bash shell scripts %}
34.描述mapreduce的执行过程，最好用画图的方式表示
{% endhighlight %}

不明。这有一篇[过程描述](http://liouwei20051000285.blog.163.com/blog/static/252367420116125223809/)。

**使用数据库设计表**

没做。

{% highlight Bash shell scripts %}
35．数据库A的ID从20120120300001到20120120399999，更新ID从00001到99999，递增加1，不重复，不间断(并保持高并发的性能)
{% endhighlight %}
---
layout: post
title: APUE笔记：进程控制与相关syscalls
categories:
- APUE
tags:
- APUE笔记
---

**1 fork与vfork**

**1.1 fork**

{% highlight c++ %}
#include <unistd.h>

pid_t fork(void);	/*返回值：子进程中返回0，父进程中返回子进程ID，出错返回-1*/
{% endhighlight %}

fork之后，子进程并不是立即获得父进程所有的副本而是采用了写时复制机制（COW）。例如，数据段、栈、堆（**fork时子进程获得父进程数据空间、堆和栈的复制**）由父子进程共享。如果父子进程有一个试图修改这些区域，则内核只为修改区域那块内存制作一个副本。

[这篇文章](http://www.cnblogs.com/zhangchaoyang/articles/2317420.html)有更详细的分析。

> *在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。*

> *fork子进程完全复制父进程的栈空间，也复制了页表，但没有复制物理页面，所以这时虚拟地址相同，物理地址也相同，但是会把父子共享的页面标记为“只读”（类似mmap的private的方式），如果父子进程一直对这个页面是同一个页面，知道其中任何一个进程要对共享的页面“写操作”，这时内核会复制一个物理页面给这个进程使用，同时修改页表。而把原来的只读页面标记为“可写”，留给另外一个进程使用。*

关于子进程继承父进程资源，APUE有一个表

![](/images/2014-05-08-1-1.PNG)

**1.2 vfork**

vfork与fork都是新创建一个进程，区别是vfork最终目的是用exec装入新程序执行，shell执行外部命令就是一个例子。而且使用*vfork，内核保证子进程调用exec或exit之前，父进程处于休眠状态，即子进程一定先运行* 。

vfork并不将父进程地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，所以也就不会访问这些地址空间。相反，子进程调用exec或exit之前，它在父进程空间中运行（简单说，就是会改变父进程的变量）。

**2 init与孤儿进程**

在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程。如果是，则将该进程的父进程ID改为1（init），这样保证每个进程都有一个父进程。  
init在其*子进程*终止时，总会调用wait获取子进程终止状态，避免了zombie进程。

内核为每个终止子进程保存了一定量的信息，当终止进程的父进程调用wait或waitpid时，可以得到这些信息。信息包括：进程ID、进程终止状态、进程使用的CPU时间总量。  
内核可是释放终止进程所有Mem、关闭器所有打开文件。

zombie进程:进程已经终止但是父进程尚未对其进行善后处理（获取子进程有关信息，释放仍占用的资源）的进程。  
除非父进程等待获取子进程终止状态，否则子进程终止后变成zombie进程。
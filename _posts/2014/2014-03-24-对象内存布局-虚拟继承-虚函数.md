---
layout: post
title: C++ 对象内存布局 虚拟继承 虚函数
categories:
- C++
tags:
- Programming
- C++
- Gcc
- VS
---

文章前2/3部分在说**虚拟继承**或者有**虚函数**的情况下对象的内存布局，后1/3提到了VS下**既有虚拟继承又有虚函数**下的内存布局。

**谈VC++对象模型**

*（美）简.格雷**，程化 译*

**0. 译者前言**

一个C++程序员，想要进一步提升技术水平的话，应该多了解一些语言的语意细节。对于使用VC++的程序员来说，还应该了解一些VC++对于C++的诠释。 Inside the C++ Object Model虽然是一本好书，然而，书的篇幅多一些，又和具体的VC++关系小一些。因此，从篇幅和内容来看，译者认为本文是深入理解C++对象模型比较好的一个出发点。
这篇文章以前看到时就觉得很好，旧文重读，感觉理解得更多一些了，于是产生了翻译出来，与大家共享的想法。虽然文章不长，但时间有限，又若干次在翻译时打盹睡着，拖拖拉拉用了小一个月。
一方面因本人水平所限，另一方面因翻译时经常打盹，错误之处恐怕不少，欢迎大家批评指正。

本文原文出处为[MSDN](http://msdn.microsoft.com/zh-cn/archive/default.asp?url=/archive/en-us/dnarvc/html/jangrayhood.asp)(jerboa:链接已失效)。如果你安装了MSDN，可以搜索到C++ Under the Hood。否则也可在网站上找到。

**1. 前言**

了解你所使用的编程语言究竟是如何实现的，对于C++程序员可能特别有意义。首先，它可以去除我们对于所使用语言的神秘感，使我们不至于对于编译器干的活感到完全不可思议；尤其重要的是，它使我们在Debug和使用语言高级特性的时候，有更多的把握。当需要提高代码效率的时候，这些知识也能够很好地帮助我们。

本文着重回答这样一些问题：

1. 类如何布局？
2. 成员变量如何访问？
3. 成员函数如何访问？
4. 所谓的“调整块”（adjuster thunk）是怎么回事？
5. 使用如下机制时，开销如何：
	- 单继承、多重继承、虚继承
	- 虚函数调用
	- 强制转换到基类，或者强制转换到虚基类
	- 异常处理

首先，我们顺次考察C兼容的结构（struct）的布局，单继承，多重继承，以及虚继承；  
接着，我们讲成员变量和成员函数的访问，当然，这里面包含虚函数的情况；  
再接下来，我们考察构造函数，析构函数，以及特殊的赋值操作符成员函数是如何工作的，数组是如何动态构造和销毁的；  
最后，简单地介绍对异常处理的支持。

对每个语言特性，我们将简要介绍该特性背后的动机，该特性自身的语意（当然，本文决不是“C++入门”，大家对此要有充分认识），以及该特性在微软的 VC++中是如何实现的。这里要注意区分抽象的C++语言语意与其特定实现。微软之外的其他C++厂商可能提供一个完全不同的实现，我们偶尔也会将 VC++的实现与其他实现进行比较。

**2. 类布局**

本节讨论不同的继承方式造成的不同内存布局。

**2.1 C结构(struct)**

由于C++基于C，所以C++也“基本上”兼容C。特别地，C++规范在“结构”上使用了和C相同的，___简单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐___ 。所有的C/C++厂商都保证他们的C/C++编译器对于有效的C结构采用完全相同的布局。这里，A是一个简单的C结构，其成员布局和对齐方式都一目了然。

![](/images/2014-03-24-2_1-1.PNG)
{% highlight c++ %}
struct A {
   char c;
   int i;
};
{% endhighlight %}
译者注：从上图可见，A在内存中占有8个字节，按照声明成员的顺序，前4个字节包含一个字符（实际占用1个字节，3个字节空着，补对齐），后4个字节包含一个整数。A的指针就指向字符开始字节处。

**2.2 有C++特征的C结构**

当然了，C++不是复杂的C，C++本质上是面向对象的语言：包含___继承___、___封装___，以及___多态___。原始的C结构经过改造，成了面向对象世界的基石——类。除了成员变量外，C++类还可以封装成员函数和其他东西。然而，有趣的是，___除非为了实现虚函数和虚继承引入的隐藏成员变量外，C++类实例的大小完全取决于一个类及其基类的成员变量！成员函数基本上不影响类实例的大小___。

这里提供的B是一个C结构，然而，该结构有一些C++特征：控制成员可见性的“public/protected/private”关键字、成员函数、静态成员，以及嵌套的类型声明。虽然看着琳琅满目，实际上，___只有成员变量才占用类实例的空间___。要注意的是，C++标准委员会不限制由“public/protected/private”关键字分开的各段在实现时的先后顺序，因此，不同的编译器实现的内存布局可能并不相同。(___在VC++中，成员变量总是按照声明时的顺序排列___)。

![](/images/2014-03-24-2_2-1.jpg)
{% highlight c++ %}
struct B {
public:
   int bm1;
protected:
   int bm2;
private:
   int bm3;
   static int bsm;
   void bf();
   static void bsf();
   typedef void* bpv;
   struct N { };
};
{% endhighlight %}
译者注：B中，为何static int bsm不占用内存空间？因为它是___静态成员，该数据存放在程序的数据段 中，不在类实例中___。

**2.3 单继承**

C++ 提供继承的目的是在不同的类型之间提取共性。比如，科学家对物种进行分类，从而有种、属、纲等说法。有了这种层次结构，我们才可能将某些具备特定性质的东西归入到最合适的分类层次上，如“怀孩子的是哺乳动物”。由于这些属性可以被子类继承，所以，我们只要知道“鲸鱼、人”是哺乳动物，就可以方便地指出“鲸鱼、人都可以怀孩子”。那些特例，如鸭嘴兽（生蛋的哺乳动物），则要求我们对缺省的属性或行为进行覆盖。  
C++中的继承语法很简单，在子类后加上“:base”就可以了。下面的D继承自基类C。

![](/images/2014-03-24-2_3-1.jpg)
{% highlight c++ %}
struct C {
   int c1;
   void cf();
};
{% endhighlight %}

![](/images/2014-03-24-2_3-2.jpg)
{% highlight c++ %}
struct D : C {
   int d1;
   void df();
};
{% endhighlight %}
既然派生类要保留基类的所有属性和行为，自然地，每个派生类的实例都包含了一份完整的基类实例数据。在D中，并不是说基类C的数据一定要放在D的数据之前，只不过这样放的话，能够保证D中的C对象地址，恰好是D对象地址的第一个字节。这种安排之下，___有了派生类D的指针，要获得基类C的指针，就不必要计算偏移量 了。几乎所有知名的C++厂商都采用这种内存安排（基类成员在前）。 在单继承类层次下，每一个新的派生类都简单地把自己的成员变量添加到基类的成员变量之后___。 看看上图，C对象指针和D对象指针指向同一地址。

**2.4 多重继承**

大多数情况下，其实单继承就足够了。但是，C++为了我们的方便，还提供了多重继承。

比如，我们有一个组织模型，其中有经理类（分任务），工人类（干活）。那么，对于一线经理类，即既要从上级经理那里领取任务干活，又要向下级工人分任务的角色来说，如何在类层次中表达呢？单继承在此就有点力不胜任。我们可以安排经理类先继承工人类，一线经理类再继承经理类，但这种层次结构错误地让经理类继承了工人类的属性和行为。反之亦然。当然，一线经理类也可以仅仅从一个类（经理类或工人类）继承，或者一个都不继承，重新声明一个或两个接口，但这样的实现弊处太多：多态不可能了；未能重用现有的接口；最严重的是，当接口变化时，必须多处维护。最合理的情况似乎是一线经理从两个地方继承属性和行为——经理类、工人类。

C++就允许用多重继承来解决这样的问题：  
{% highlight c++ %}
struct Manager ... { ... };
struct Worker ... { ... };
struct MiddleManager : Manager, Worker { ... };
{% endhighlight %}  
这样的继承将造成怎样的类布局呢？下面我们还是用“字母类”来举例：

![](/images/2014-03-24-2_4-1.jpg)
{% highlight c++ %}
struct E {
   int e1;
   void ef();
};
{% endhighlight %}

![](/images/2014-03-24-2_4-2.jpg)
{% highlight c++ %}
struct F : C, E {
   int f1;
   void ff();
};
{% endhighlight %}